---
title: "Bladder cancer recurrence analysis"
author: "Rob Daniels"
date: "`r Sys.Date()`"
bibliography: bibliography/references.bib
csl: bibliography/apa.csl
format: 
  html:
    output-file: index.html
    toc: true
    toc-floating: true
    html-math-method: mathjax
    eqn-numbering: by-id
    df-print: kable
execute:
  warning: false
  message: false
editor: visual
---

# Description

This document presents an analysis of the classic bladder cancer recurrence data. It illustrates advanced statistical approaches to recurrent events survival analysis while demonstrating the use of modern data science tools and workflows, including:

-   Version control & reproducibility: GitHub, Quarto, Markdown, bibliographic integration
-   Statistical programming: R
-   Visualization & reporting: HTML, LaTeX, ggplot2, plotly
-   Statistical methods: recurrent events survival analysis

```{r}
#| label: setup
#| include: false

# load libraries and data
library(dplyr)
library(tidyverse)
library(survival)
library(DT)
library(ggplot2)
library(plotly)

data(cancer, package="survival")
```

# Data

Data are from [@Byar1977]. Per the R survival package [documentation](https://rdrr.io/cran/survival/man/bladder.html){target="_blank"}, the `bladder1` data set is the full data set. Patients entered the study after removal of superficial bladder tumors. They were randomized into one of three treatment arms and followed for tumor recurrence for up to 64 months. Censoring occurs either at loss to follow-up or death These are interval-level survival data and contain the following variables:

```         
id        : subject ID
treatment : treatment group (placebo, pyridoxine, or thiotepa)
number    : number of initial tumors
size      : size of the largest initial tumor (cm)
recur     : number of recurrences
start     : start of the interval (0 or previous event time)
stop      : end of interval; recurrence or censoring time
status    : end of interval code
            (0 = censored, 1 = recurrence, 
             2 = death from bladder disease, 
             3 = other death or unknown)
rtumor    : number of tumors at recurrence
rsize     : size of largest tumor at recurrence (cm)
enum      : event number
```

<details>

<summary>Click to show full data set.</summary>

```{r}
#| label: full_data
#| echo: false
datatable(bladder1,
          options = list(
            pageLength = 10,
            scrollX = TRUE,
            scrollY = "400px"
            )
)
```

</details>

# Full data set descriptives

Number of subjects.

```{r}
#| label: number-of-subjects
#| code-fold: true

# number of subjects
cat(length(unique(bladder1$id)))
```

Subjects per treatment arm.

```{r}
#| label: subject-count-per-trt
#| code-fold: true

# subject count and percent per treatment arm
ids_per_trt <- bladder1 %>%
  distinct(treatment, id) %>%
  count(treatment, name = "subj") %>%
  mutate(pct = round(100 * subj / sum(subj), 1))

print(ids_per_trt, row.names = FALSE)
```

Total number of recurrences.

```{r}
#| label: recurrences
#| code-fold: true

# number of recurrences (2 equivalent ways)
# cat(sum(tapply(bladder1$recur, bladder1$id, max)))
cat(sum(bladder1$status == 1))
```

Recurrence frequencies. 52.5% of subjects had at least one recurrence.

```{r}
#| label: recurrence-freqs
#| code-fold: true

# recurrence frequencies
recur_freqs <- bladder1 %>%
  group_by(id) %>%
  summarize(recurrences = max(recur, na.rm = TRUE), .groups = "drop") %>%
  count(recurrences, name = "subj") %>%
  mutate(pct = round(100 * subj / sum(subj), 1)) %>%
  as.data.frame()

print(recur_freqs, row.names = FALSE)
```

Distribution of number of recurrences. The mean number of recurrences was 1.6.

```{r}
#| label: recurrence-dist
#| code-fold: true

# distribution of number of recurrences
summary(tapply(bladder1$recur, bladder1$id, max), digits = 2)
```

# Recurrent events plot

```{r}
#| label: events-plot
#| code-fold: true
#| fig-width: 12
#| fig-height: 12
#| dpi: 150

# recurrent events plots
plot_data <- bladder1 %>%
  mutate(id_factor = factor(id, levels = unique(id)),
         event = case_when(status == 1 ~ "Recurrence",
                           status == 0 ~ "Censored",
                           status == 2 ~ "Bladder cancer death",
                           status == 3 ~ "Other death/unknown",
                           TRUE        ~ NA_character_),
         event = factor(event, levels = c(
           "Recurrence",
           "Censored",
           "Bladder cancer death",
           "Other death/unknown")))

event_plot <- ggplot(plot_data, aes(y = id_factor)) +
  geom_segment(aes(x = start, xend = stop, yend = id_factor), 
               color = "grey60") + 
  geom_point(data = filter(plot_data, !is.na(event)),
             aes(x = stop, shape = event, colour = event,
                 text = paste("ID:", id, "<br>Status:", event, 
                              "<br>Time:", stop)), 
             size = 1.5, stroke = 0.5) +
  scale_shape_manual(
    values = c(
      "Recurrence"           = 16,
      "Censored"             = 1,
      "Bladder cancer death" = 4,
      "Other death/unknown"  = 17)) +
  scale_color_manual(
    values = c(
      "Recurrence"           = "black",
      "Censored"             = "black",
      "Bladder cancer death" = "red",
      "Other death/unknown"  = "blue")) +
  scale_y_discrete("Subject",
                   expand = expansion(mult = c(0.02, 0.02))) +
  scale_x_continuous("Months since enrollment") +
  facet_wrap(~treatment, ncol = 1, scales = "free_y") +
  coord_cartesian(clip = "off") +
  theme_minimal(base_size = 12) +
  theme(plot.margin = margin(15, 15, 15, 15),
        legend.position = "right",
        strip.placement = "outside",
        strip.text.y = element_text(angle = 90),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(shape = "Event type", color = "Event type")

interactive_plot <- ggplotly(event_plot, tooltip = "text")

htmlwidgets::saveWidget(interactive_plot,
                        "bladder_recurrence_event_plot.html",
                        selfcontained = TRUE)

ggplotly(event_plot, tooltip = "text")
```

<br> [Click here to open an interactive plot in a new window](bladder_recurrence_event_plot.html){target="_blank"}

# Traditional analyses

This section walks through several commonly used models for analyzing recurrent event data. Many of the results align with those published in the [SAS PROC PHREG documentation](https://documentation.sas.com/doc/en/statug/15.2/statug_phreg_examples10.htm){target="_blank"}. For consistency, the analyses use a reduced version of the `bladder1` data set.

## Reduced data set

The reduced data set includes only patients in the placebo and thiotepa treatment arms (86 subjects) and is limited to the first four recurrences for each subject. One subject had no follow-up and is typically excluded from analyses. Each subject contributes up to four observations (total observations = 344). For subjects with fewer than four recurrences, the last available recurrence is repeated to fill the remaining rows. The data set contains the following variables:

```         
id        : subject ID (regenerated)
id_orig   : original ID from full data set
trt       : treatment group (1 = placebo, 2 = thiotepa)
number    : number of initial tumors
size      : size of the largest initial tumor (cm)
tstart    : start of the interval (0 or previous event time)
tstop     : end of interval; recurrence or censoring time
status    : end of interval code (0 = censored, 1 = recurrence)
visit     : visit/event number
```

The following code generates the reduced data set from the full data set. IDs have been regenerated in order to match published versions of the data. `id_orig` corresponds to the subject ID in the full data set. `trt1–trt4`, `number1–number4`, and `size1–size4` are also created, which are corresponding `visit`-interaction variables used in later analyses.

```{r}
#| label: reduced-data
#| code-fold: true

# reduced data set (combination of WLW and AG styles)
bladder_reduced <- bladder1 %>%
  filter(treatment %in% c("placebo", "thiotepa"),
         enum <= 4) %>%
  mutate(id_orig = id, 
         id = dense_rank(id),
         trt = if_else(treatment == "placebo", 1, 2),
         event = if_else(status == 1, 1, 0)) %>%
  group_by(id) %>%
  complete(enum = 1:4) %>%
  arrange(id, enum) %>%
  fill(id_orig, trt, number, size, stop, .direction = "down") %>%
  mutate(tstart = as.integer(if_else(row_number() == 1, 0, lag(stop))),
         status = if_else(is.na(event), 0, event),
         visit = as.integer(enum)) %>%
  ungroup() %>%
  mutate(trt1 = trt*(visit == 1),
         trt2 = trt*(visit == 2),
         trt3 = trt*(visit == 3),
         trt4 = trt*(visit == 4),
         number1 = number*(visit == 1),
         number2 = number*(visit == 2),
         number3 = number*(visit == 3),
         number4 = number*(visit == 4),
         size1 = size*(visit == 1),
         size2 = size*(visit == 2),
         size3 = size*(visit == 3),
         size4 = size*(visit == 4)) %>%
  select(id, id_orig, trt, number, size, tstart, tstop = stop, status, visit, 
         trt1, trt2, trt3, trt4, number1, number2, number3, number4, size1, 
         size2, size3, size4)
```

<details>

<summary>Click to show reduced data set.</summary>

```{r}
#| label: show-reduced-data
#| echo: false
datatable(bladder_reduced,
          options = list(
            pageLength = 10,
            scrollX = TRUE,
            scrollY = "400px"
            )
)
```

</details>

## Reduced data descriptives

Number of subjects.

```{r}
#| label: reduced-number-of-subjects
#| code-fold: true

# number of subjects
cat(length(unique(bladder_reduced$id)))
```

Subjects per treatment arm.

```{r}
#| label: reduced-subject-count-per-trt
#| code-fold: true

# subject count and percent per treatment arm
ids_per_trt <- bladder_reduced %>%
  distinct(trt, id) %>%
  count(trt, name = "subj") %>%
  mutate(pct = round(100 * subj / sum(subj), 1)) %>%
  as.data.frame()

print(ids_per_trt, row.names = FALSE)
```

Total number of recurrences.

```{r}
#| label: reduced-recurrences
#| code-fold: true

# number of recurrences (2 equivalent ways)
# cat(sum(tapply(bladder_reduced$status, bladder_reduced$id, sum)))
cat(sum(bladder_reduced$status == 1))
```

Recurrence frequencies. 54.7% of subjects had at least one recurrence.

```{r}
#| label: reduced-recurrence-freqs
#| code-fold: true

# recurrence frequencies
recur_freqs <- bladder_reduced %>%
  group_by(id) %>%
  summarize(recurrences = sum(status), .groups = "drop") %>%
  count(recurrences, name = "subj") %>%
  mutate(pct = round(100 * subj / sum(subj), 1)) %>%
  as.data.frame()

print(recur_freqs, row.names = FALSE)
```

Distribution of number of recurrences. The mean number of recurrences was 1.3.

```{r}
#| label: reduced-recurrence-dist
#| code-fold: true

# distribution of number of recurrences
summary(tapply(bladder_reduced$status, bladder_reduced$id, sum), digits = 2)
```

## Reduced data recurrent events plot

```{r}
#| label: reduced-events-plot
#| code-fold: true
#| fig-width: 12
#| fig-height: 12
#| dpi: 150

# recurrent events plots for reduced data
plot_data <- bladder_reduced %>%
  group_by(id) %>%
  mutate(total_followup = max(tstop)) %>%
  ungroup() %>%
  mutate(id_factor = factor(id, levels =
                              unique(id[order(total_followup)])),
         trt = factor(trt, levels = c(1, 2),
                      labels = c("placebo", "thiotepa")),
         event = case_when(status == 1 ~ "Recurrence",
                           status == 0 ~ "Censored",
                           TRUE        ~ NA_character_),
         event = factor(event, levels = c("Recurrence",
                                          "Censored")))

event_plot <- ggplot(plot_data, aes(y = id_factor)) +
  geom_segment(aes(x = tstart, xend = tstop, yend = id_factor), 
               color = "grey60") + 
  geom_point(data = filter(plot_data, !is.na(event)),
             aes(x = tstop, shape = event, colour = event,
                 text = paste("ID:", id, "<br>Original ID:", id_orig, 
                              "<br>Status:", event, "<br>Time:", tstop)),
             size = 1.5, stroke = 0.5) +
  scale_shape_manual(
    values = c("Recurrence" = 16, 
               "Censored"   = 1)) +
  scale_color_manual(
    values = c("Recurrence" = "black",
               "Censored"   = "black")) +
  scale_y_discrete("Subject",
                   expand = expansion(mult = c(0.02, 0.02))) +
  scale_x_continuous("Months since enrollment") +
  facet_wrap(~trt, ncol = 1, scales = "free_y") +
  coord_cartesian(clip = "off") +
  theme_minimal(base_size = 12) +
  theme(plot.margin = margin(15, 15, 15, 15),
        legend.position = "right",
        strip.placement = "outside",
        strip.text.y = element_text(angle = 90),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(shape = "Event type", color = "Event type")

interactive_plot <- ggplotly(event_plot, tooltip = "text")

htmlwidgets::saveWidget(interactive_plot, "bladder_recurrence_reduced_event_plot.html", selfcontained = TRUE)

ggplotly(event_plot, tooltip = "text")
```

<br> [Click here to open an interactive plot in a new window](bladder_recurrence_reduced_event_plot.html){target="_blank"}

## AG intensity model

First, the Andersen–Gill (AG) intensity model [@Andersen1982] is fit to the data. This is a counting-process formulation of the semi-parametric Cox proportional hazards model, where the hazard (referred to as "intensity" here because events are repeatable) at time $t$ for subject $i$ is

$$
\lambda_i(t \mid Z_i(t)) = \lambda_0(t) \, \exp \{ \beta^\top Z_i(t)\}
$$ {#eq-ag}

and where $\lambda_0(t)$ is an unspecified baseline intensity (hazard) function, $Z_i(t)$ is the vector of possibly time-varying covariates for subject $i$, and $\beta$ is the vector of regression coefficients. The AG method treats recurrent events as arising from a counting process and assumes a time-transformed Poisson process; covariates have multiplicative effects on both the mean and rate functions of the process.

The code to fit this model in R is below.  The Efron method is used to handle tied event times; using the Breslow method produces results that exactly match those in the [SAS PROC PHREG documentation](https://documentation.sas.com/doc/en/statug/15.2/statug_phreg_examples10.htm){target="_blank"}.

```{r}
#| label: AG-intensity-model
#| code-fold: true

# fit AG intensity model
intensity <- coxph(
  Surv(tstart, tstop, status) ~ trt + number + size,
  ties = "efron", # change to breslow for exact match with SAS results
  data = bladder_reduced %>% filter(tstop > tstart)
)

summary(intensity)
```

The thiotepa arm shows a statistically significant reduction in the hazard of bladder cancer recurrence compared with placebo (HR = 0.63; 95% CI: 0.42–0.93; $p$ = 0.020), corresponding to an estimated 37% lower instantaneous risk. Each additional initial tumor is associated with a 19% increase in hazard (HR = 1.19; 95% CI: 1.09–1.31; $p$ < 0.001). Tumor size at baseline shows no clear association with recurrence (HR = 0.96; $p$ = 0.53).

The model’s concordance index ($C$ = 0.63) indicates relatively poor discrimination of which patients recur earlier versus later, and the global tests all confirm that at least one predictor is significantly related to recurrence risk.

This model does not account for the dependent nature of recurrent events within subject.

## Proportional means model

Next, the proportional means model [@Lin2000] is fit to the data. The Efron method is used to handle tied event times; using the Breslow method produces results that exactly match those in the [SAS PROC PHREG documentation](https://documentation.sas.com/doc/en/statug/15.2/statug_phreg_examples10.htm){target="_blank"}.

```{r}
#| label: prop-means-model
#| code-fold: true

# Lin et al (2000) proportional means model
prop_means <- coxph(
  Surv(tstart, tstop, status) ~ trt + number + size + cluster(id),
  ties = "efron", # change to breslow for exact match with SAS results
  data = bladder_reduced %>% filter(tstop > tstart)
)

summary(prop_means)
```

The point estimates in the proportional means model are identical to those from the Andersen–Gill (AG) intensity model because both use the same partial likelihood and score equations for estimating regression parameters. The AG model characterizes the instantaneous rate (hazard) of the next event, conditional on an individual’s event history. In contrast, the proportional means model compares groups in terms of the mean (expected) cumulative number of events by time $t$, producing rate ratios for the mean cumulative count. For example, a coefficient of $log(0.67)$ indicates that, by time $t$, the treatment arm is expected to have about 33% fewer recurrences than the control arm.

The difference lies in variance estimation. The proportional means model employs a robust (sandwich) variance estimator as developed by [@Lin1989] to account for within-subject correlation among repeated events. After this adjustment, the treatment effect is no longer statistically significant ($p = 0.08$).

## Second data transformation

To fit some additional types of models, the data will need to be transformed again. With the following, each risk set is restricted to patients who have experienced the corresponding number of prior events. For example, a patient who has only two events does not enter the risk sets for the third or fourth recurrence. A new variable, `gap_time`, is created to represent the time between successive recurrences. `trt1–trt4`, `number1–number4`, and `size1–size4` are corresponding `visit`-interaction variables used the following analyses.

```{r}
#| label: second-transformation-data
#| code-fold: true

# second data transformation, style used by PWP (R documentation refers to this 
# as AG style) see https://rdrr.io/cran/survival/man/bladder.html
bladder2_reduced <- bladder_reduced %>%
  arrange(id, tstart, tstop) %>%
  group_by(id) %>%
  mutate(last_status = lag(status, default = 1)) %>%
  filter(!(status == 0 & last_status == 0)) %>%
  mutate(gap_time = tstop - tstart) %>%
  ungroup() %>%
  filter(gap_time != 0) %>%
  mutate(trt1 = trt*(visit == 1),
         trt2 = trt*(visit == 2),
         trt3 = trt*(visit == 3),
         trt4 = trt*(visit == 4),
         number1 = number*(visit == 1),
         number2 = number*(visit == 2),
         number3 = number*(visit == 3),
         number4 = number*(visit == 4),
         size1 = size*(visit == 1),
         size2 = size*(visit == 2),
         size3 = size*(visit == 3),
         size4 = size*(visit == 4)) %>%
  select(id, id_orig, trt, number, size, tstart, tstop, status, visit, gap_time,
         trt1, trt2, trt3, trt4, number1, number2, number3, number4, size1, 
         size2, size3, size4)
```

<details>

<summary>Click to show the transformed data set.</summary>

```{r}
#| label: show-second-transformation-data
#| echo: false
datatable(bladder2_reduced,
          options = list(
            pageLength = 10,
            scrollX = TRUE,
            scrollY = "400px"
            )
)
```

</details>

The number of events and censored values are summarized below.

```{r}
#| label: num-event-censored
#| code-fold: true

summary_tab <- with(bladder2_reduced, table(visit, status)) |>
  as.data.frame() |>
  pivot_wider(names_from = status, values_from = Freq, values_fill = 0) |>
  rename(censored = `0`, event = `1`) |>
  mutate(total = censored + event,
         pct_censored = round(100 * censored / total, 1))

summary_tab <- bind_rows(
  summary_tab,
  summarise(summary_tab,
            visit = "Total",
            censored = sum(censored),
            event = sum(event),
            total = sum(total),
            pct_censored = round(100 * censored / total, 1))) %>%
  as.data.frame()

print(summary_tab, row.names = FALSE)
```

## PWP total time model

The following models are the total time (TT) models of Prentice, Williams, and Peterson [@Prentice1981]. They are stratified models. and the visit-specific variables, `trt1–trt4`, `number1–number4`, and `size1–size4`, are used in the uncommon effects models.

### Uncommon effects

```{r}
#| label: pwp-tt-uc-model
#| code-fold: true
#| echo: true
# PWP (1981) total time model with uncommon effects
pwp_tt_uc <- coxph(
  Surv(tstart, tstop, status) ~ trt1 + trt2 + trt3 + trt4 + 
    number1 + number2 + number3 + number4 + size1 + size2 + size3 + size4 + 
    strata(visit), # or, equivalently: (trt + number + size) * strata(visit)
  ties = "efron", # replace with "breslow" for exact match with SAS
  data = bladder2_reduced
)

summary(pwp_tt_uc)
```

Results show that there is no significant treatment effect on the total time for any of the four tumor recurrences.

### Common effects

The PWP-TT model with common effects is shown below.

```{r}
#| label: pwp-tt-c-model
#| code-fold: true
#| echo: true

# PWP (1981) total time model with common effects
pwp_tt_c <- coxph(
  Surv(tstart, tstop, status) ~ trt + number + size + strata(visit),
  ties = "efron",
  data = bladder2_reduced
)

summary(pwp_tt_c)
```

## PWP gap-time model

The following models are the gap-time (PWP-GT) models of [@Prentice1981]. They are stratified models and the visit-specific variables, `trt1–trt4`, `number1–number4`, and `size1–size4`, are used in the uncommon effects models.

### Uncommon effects

```{r}
#| label: pwp-gt-uc-model
#| code-fold: true
#| echo: true

# PWP (1981) gap-time model with uncommon effects
pwp_gt_uc <- coxph(
  Surv(gap_time, status) ~ trt1 + trt2 + trt3 + trt4 + 
    number1 + number2 + number3 + number4 + 
    size1 + size2 + size3 + size4 + strata(visit),
  ties = "efron", # replace with "breslow" for exact match with SAS
  data = bladder2_reduced
)

summary(pwp_gt_uc)
```

Results show that there is no significant treatment effect on any of the gap-times for any of the four tumor recurrences. The coefficients for the gap-time model match the coefficients for the total time model for the first recurrence since they are the same for the first recurrence.

### Common effects

The PWP gap-time model with common effects is shown below.

```{r}
#| label: pwp-gt-c-model
#| code-fold: true
#| echo: true

# PWP (1981) gap-time model with common effects
pwp_gt_c <- coxph(
  Surv(gap_time, status) ~ trt + number + size + strata(visit),
  ties = "efron",
  data = bladder2_reduced
)

summary(pwp_gt_c)
```

The results show there is no significant treatment effect.

## Wei-Lin-Weissfeld model

The multivariate marginal approach of [@Wei1989] is shown next.

```{r}
#| label: wlw-model
#| code-fold: true
#| echo: true

# WLW (1989) marginal model
wlw <- coxph(
  Surv(tstop, status) ~ trt1 + trt2 + trt3 + trt4 + 
    number1 + number2 + number3 + number4 + 
    size1 + size2 + size3 + size4 + strata(visit) + cluster(id),
  ties = "efron", # replace with "breslow" to match SAS results
  data = bladder_reduced,
  x = TRUE
)

summary(wlw)
```

The following code further processes the results to construct global tests of no treatment (trt) effect. A global 4 degrees of freedom chi-square test is constructed first.

```{r}
#| label: wlw-model-trt-effect
#| code-fold: true
#| echo: true

# extract trt variance-covariance and parameter estimates
vcov_mat <- vcov(wlw)[c("trt1", "trt2", "trt3", "trt4"),
                      c("trt1", "trt2", "trt3", "trt4")]
beta_hat <- coef(wlw)[c("trt1", "trt2", "trt3", "trt4")]

# construct global chi-square test
chisq_4df <- as.numeric(t(beta_hat) %*% solve(vcov_mat, beta_hat))
pval_chisq_4df <- pchisq(chisq_4df, df = length(beta_hat), lower.tail = FALSE)

result <- data.frame(
  chi_sq = round(chisq_4df, 2),
  df = length(beta_hat),
  p_value = signif(pval_chisq_4df, 4)
)

print(result, row.names = FALSE)
```

There is not enough evidence of a treatment effect in any of the four recurrences ($p$ = 0.4189). Optimal weights for estimating the common treatment effect can be calculated as follows.

```{r}
#| label: wlw-model-opt-weights
#| code-fold: true
#| echo: true

# get optimal weights by minimizing the variance of the linear combination
one <- rep(1, length(beta_hat))
w <- solve(vcov_mat, one)

# optimal weights
w <- w / sum(w)   # normalize to sum to 1
print(round(w, 5))
```

Test for average (common) treatment effect.

```{r}
#| label: wlw-model-avg-effect
#| code-fold: true
#| echo: true

# average effect
beta_common <- sum(w * beta_hat)

# variance of average effect
var_common <- as.numeric(1 / (t(one) %*% solve(vcov_mat, one)))
se_common <- sqrt(var_common)

# z-score
z <- beta_common / se_common

# p-value
pval_z <- 2 * pnorm(-abs(z))

result <- data.frame(
  estimate = format(round(beta_common, 4), width = 9),
  std_err  = format(round(se_common, 4), width = 8),
  z_score  = format(round(z, 4), width = 8),
  p_value  = format(signif(pval_z, 4), width = 8)
)

print(result, row.names = FALSE)
```

# Acknowledgements

Paul Allison's *Survival Analysis Using SAS* [@Allison2010] and the course website for **BMI/STAT 741: Applied Survival Analysis** (Spring 2025), developed by Prof. Lu Mao (University of Wisconsin–Madison), were consulted to inform aspects of my analyses.

ChatGPT [@openai2025gpt5] was used for coding assistance, editing, and checking some statistical concepts; all final decisions and interpretations are my own.